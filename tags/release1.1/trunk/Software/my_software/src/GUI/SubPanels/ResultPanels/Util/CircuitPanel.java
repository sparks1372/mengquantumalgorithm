/*
 * CircuitPanel.java - Class of the jQuantum computer simulator
 *
 * Copyright (C) 2004-2008 Andreas de Vries
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see http://www.gnu.org/licenses
 * or write to the Free Software Foundation,Inc., 51 Franklin Street,
 * Fifth Floor, Boston, MA 02110-1301  USA
 */

package GUI.SubPanels.ResultPanels.Util;

import java.awt.Color;
import java.awt.Graphics;
import java.util.Iterator;

import Core.Circuit.Circuit;
import Core.Circuit.quantumgate;
import Core.CircuitEvolution.multiqubitquantumgate;
import Core.CircuitEvolution.GateImplementations.ControlledU_Gate;
import Core.CircuitEvolution.GateImplementations.Swap_Gate;

/**
 * This class serves to show the panel on which the quantum circuits are
 * displayed.
 * 
 * @author Andreas de Vries
 * @version 1.6
 */
public class CircuitPanel extends javax.swing.JPanel {
	private static final long			serialVersionUID	= 727054267;
	/** The circuit of of quantum gates which is displayed. */
	private final Core.Circuit.Circuit	circuit;
	/** The circuit of of quantum gates which is displayed. */
	private java.util.Properties		bundle;
	private final int					numOfQubits;
	private final int					fontSize			= 10;
	private final int					xDelta				= 50;			// stepwidth
	// of
	// each
	// gate
	private int							yDelta;
	private int							x					= 0, y, y0 = 0;
	private int							y1					= 0;
	private int							y2					= 0;
	private final int					adjust				= 2;			// constant

	// number
	// of
	// pixels
	// to
	// adjust
	// the
	// height
	// of

	// wires and gates

	/**
	 * Creates new CircuitPanel.
	 * 
	 * @param circuit
	 *            the quantum circuit to be displayed
	 */
	public CircuitPanel(Circuit circuit, int num) {
		this.circuit = circuit;
		numOfQubits = num;
		initComponents();
	}

	private void drawGate(Graphics g, quantumgate gate, int i) {
		x = (i + 1) * xDelta;
		y0 = (2 * (numOfQubits - gate.getTarget()) + 1) * yDelta / 2 + adjust;
		drawGate(g, gate, i, x, y0);
	}

	private void drawGate(Graphics g, quantumgate gate, int i, int x, int y) {
		int gateHeight = 12;
		g.setColor(Color.white);
		g.fillRect(x, y0 - gateHeight / 2, xDelta / 2, gateHeight);
		g.setColor(Color.black);
		g.drawRect(x, y0 - gateHeight / 2, xDelta / 2, gateHeight);
		x = (4 * i + 5) * xDelta / 4 - 3;
		g.drawString(gate.getlabel(), x, y0 + 4);
	}

	/**
	 * This method is called from within the constructor to initialize this
	 * circuit panel. Note, however, that this class has no GUI components.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	private void initComponents() {// GEN-BEGIN:initComponents

	}// GEN-END:initComponents

	/**
	 * Paints and repaints the circuit panel.
	 * 
	 * @param g
	 *            the Graphic object
	 */
	@Override
	public void paint(Graphics g) {
		super.paint(g);
		x = 0;
		y0 = 0;
		y1 = 0;
		y2 = 0;
		if (numOfQubits > 0) {
			yDelta = (getHeight() - 3) / numOfQubits;
			yDelta = yDelta > 20 ? yDelta : 20;

			// adapt width of this panel because of scroll pane:
			setPreferredSize(new java.awt.Dimension((circuit.getSize() + 1)
					* xDelta, (yDelta * numOfQubits) + 3));
			revalidate(); // notify the scroll pane (if any)!

			g.setFont(new java.awt.Font("Helvetica", java.awt.Font.PLAIN,
					fontSize));
			int fontHeight = g.getFontMetrics().getHeight();

			// int currentGate = circuit.getNextGateNumber();
			int xRegisterSize = numOfQubits;

			// // mark current gate position during a quantum circuit execution:
			// if ((currentGate > 0) && (currentGate <= circuit.size())) {
			// x = (5 * (currentGate + 1) - 1) * xDelta / 5;
			// g.setColor(new java.awt.Color(0, 128, 0));
			// g.drawLine(x, 1, x, getHeight() - 1);
			// g.setColor(java.awt.Color.black);
			// }

			// The gap between the two registers:
			int gap = 5;

			// The radius of dots and cycles:
			int radius;

			// draw tips of the wires:
			for (int i = 0; i < numOfQubits; i++) {
				y = (2 * i + 1) * yDelta / 2 + adjust;
				g.drawLine(0, y, xDelta, y);
			}

			// ticks for the wires:
			g.setColor(new java.awt.Color(127, 127, 127));
			for (int i = 0; i < numOfQubits; i++) {
				g.drawString("" + (numOfQubits - i), 0, (2 * i + 1) * yDelta
						/ 2 + adjust);
			}
			g.setColor(java.awt.Color.black);

			quantumgate gate; // stores the next gate in each iteration
			Iterator<quantumgate> iter = circuit.getCircuitlayout();
			int i = 0;
			while (iter.hasNext()) {
				gate = iter.next();

				// draw wires:
				for (int il = 0; il < numOfQubits; il++) {
					y = (2 * (numOfQubits - il) - 1) * yDelta / 2 + adjust;
					g.drawLine((i + 1) * xDelta, y, (i + 2) * xDelta, y);
				}

				int max = 0, min = 0;
				if (gate instanceof multiqubitquantumgate) {
					max = gate.getTarget() < ((multiqubitquantumgate) gate)
							.getSecondQubit() ? ((multiqubitquantumgate) gate)
							.getSecondQubit() : gate.getTarget();
					min = gate.getTarget() > ((multiqubitquantumgate) gate)
							.getSecondQubit() ? ((multiqubitquantumgate) gate)
							.getSecondQubit() : gate.getTarget();
				}

				if (gate instanceof ControlledU_Gate) {
					radius = numOfQubits <= 5 ? 3 : 2;
					x = (4 * i + 5) * xDelta / 4;
					y0 = (2 * (xRegisterSize - gate.getTarget()) + 1) * yDelta
							/ 2 + adjust;
					y1 = (2 * (xRegisterSize - ((multiqubitquantumgate) gate)
							.getSecondQubit()) + 1) * yDelta / 2 + adjust;
					g.fillOval(x - radius, y1 - radius, 2 * radius, 2 * radius);
					radius = numOfQubits <= 5 ? 6 : 4;
					if (y0 > y1) {
						g.drawLine(x, y0, x, y1 + radius);
					} else {
						g.drawLine(x, y0, x, y1 - radius);
					}

					drawGate(g, gate, i);

				} else if (gate instanceof Swap_Gate) {
					radius = numOfQubits <= 5 ? 3 : 2;
					x = (4 * i + 5) * xDelta / 4;
					y0 = (2 * (xRegisterSize - gate.getTarget()) + 1) * yDelta
							/ 2 + adjust;
					y1 = (2 * (xRegisterSize - ((multiqubitquantumgate) gate)
							.getSecondQubit()) + 1) * yDelta / 2 + adjust;

					g.drawLine(x - radius, y0 - radius, x + radius, y0 + radius);
					g.drawLine(x - radius, y0 + radius, x + radius, y0 - radius);

					g.drawLine(x, y0, x, y1);

					g.drawLine(x - radius, y1 - radius, x + radius, y1 + radius);
					g.drawLine(x - radius, y1 + radius, x + radius, y1 - radius);

				} else {
					drawGate(g, gate, i);
				}
				// else if (gate instanceof Pauli_Y) {
				// gateHeight = 12;
				// x = (i + 1) * xDelta;
				// y0 = (2 * (xRegisterSize - gate.getTarget()) + 1) * yDelta
				// / 2 + adjust;
				// g.setColor(Color.white);
				// g.fillRect(x, y0 - gateHeight / 2, xDelta / 2, gateHeight);
				// g.setColor(Color.black);
				// g.drawRect(x, y0 - gateHeight / 2, xDelta / 2, gateHeight);
				// x = (4 * i + 5) * xDelta / 4 - 3;
				// g.drawString("Y", x, y0 + 4);
				// } else if (gate.name.equalsIgnoreCase("Pauli-Z")) {
				// gateHeight = 12;
				// x = (i + 1) * xDelta;
				// if (gate.yRegister) {
				// y0 = (2 * (numberOfWires - gate.qubits[0]) + 1)
				// * yDelta / 2 + gap + adjust;
				// } else {
				// y0 = (2 * (xRegisterSize - gate.qubits[0]) + 1)
				// * yDelta / 2 + adjust;
				// max += yRegisterSize;
				// min += yRegisterSize;
				// }
				// g.setColor(Color.white);
				// g.fillRect(x, y0 - gateHeight / 2, xDelta / 2,
				// gateHeight);
				// g.setColor(Color.black);
				// g.drawRect(x, y0 - gateHeight / 2, xDelta / 2,
				// gateHeight);
				// x = (4 * i + 5) * xDelta / 4 - 3;
				// g.drawString("Z", x, y0 + 4);
				// } else if (gate.name.equalsIgnoreCase("S")) {
				// gateHeight = 12;
				// x = (i + 1) * xDelta;
				// if (gate.yRegister) {
				// y0 = (2 * (numberOfWires - gate.qubits[0]) + 1)
				// * yDelta / 2 + gap + adjust;
				// } else {
				// y0 = (2 * (xRegisterSize - gate.qubits[0]) + 1)
				// * yDelta / 2 + adjust;
				// max += yRegisterSize;
				// min += yRegisterSize;
				// }
				// g.setColor(Color.white);
				// g.fillRect(x, y0 - gateHeight / 2, xDelta / 2,
				// gateHeight);
				// g.setColor(Color.black);
				// g.drawRect(x, y0 - gateHeight / 2, xDelta / 2,
				// gateHeight);
				// x = (4 * i + 5) * xDelta / 4 - 3;
				// g.drawString("S", x, y0 + 4);
				// } else if (gate.name.equalsIgnoreCase("invS")) {
				// gateHeight = 12;
				// x = (i + 1) * xDelta;
				// if (gate.yRegister) {
				// y0 = (2 * (numberOfWires - gate.qubits[0]) + 1)
				// * yDelta / 2 + gap + adjust;
				// } else {
				// y0 = (2 * (xRegisterSize - gate.qubits[0]) + 1)
				// * yDelta / 2 + adjust;
				// max += yRegisterSize;
				// min += yRegisterSize;
				// }
				// g.setColor(Color.white);
				// g.fillRect(x, y0 - gateHeight / 2, xDelta / 2,
				// gateHeight);
				// g.setColor(Color.black);
				// g.drawRect(x, y0 - gateHeight / 2, xDelta / 2,
				// gateHeight);
				// x = (4 * i + 5) * xDelta / 4 - 3;
				// g.drawString("S", x - 2, y0 + 4);
				// x += fontSize - 3;
				// y0 += 2 + fontSize / 5 - gateHeight / 2;
				// g.drawLine(x, y0 - fontSize / 5, x, y0 + fontSize / 3);
				// g.drawLine(x - 2, y0, x + 2, y0);
				// } else if (gate.name.equalsIgnoreCase("T")) {
				// gateHeight = 12;
				// x = (i + 1) * xDelta;
				// if (gate.yRegister) {
				// y0 = (2 * (numberOfWires - gate.qubits[0]) + 1)
				// * yDelta / 2 + gap + adjust;
				// } else {
				// y0 = (2 * (xRegisterSize - gate.qubits[0]) + 1)
				// * yDelta / 2 + adjust;
				// max += yRegisterSize;
				// min += yRegisterSize;
				// }
				// g.setColor(Color.white);
				// g.fillRect(x, y0 - gateHeight / 2, xDelta / 2,
				// gateHeight);
				// g.setColor(Color.black);
				// g.drawRect(x, y0 - gateHeight / 2, xDelta / 2,
				// gateHeight);
				// x = (4 * i + 5) * xDelta / 4 - 3;
				// g.drawString("T", x, y0 + 4);
				// } else if (gate.name.equalsIgnoreCase("sqrt-X")) {
				// gateHeight = 12;
				// x = (i + 1) * xDelta;
				// if (gate.yRegister) {
				// y0 = (2 * (numberOfWires - gate.qubits[0]) + 1)
				// * yDelta / 2 + gap + adjust;
				// } else {
				// y0 = (2 * (xRegisterSize - gate.qubits[0]) + 1)
				// * yDelta / 2 + adjust;
				// max += yRegisterSize;
				// min += yRegisterSize;
				// }
				// g.setColor(Color.white);
				// g.fillRect(x, y0 - gateHeight / 2, xDelta / 2,
				// gateHeight);
				// g.setColor(Color.black);
				// g.drawRect(x, y0 - gateHeight / 2, xDelta / 2,
				// gateHeight);
				// x = (4 * i + 5) * xDelta / 4 - fontHeight / 2;
				// g.drawString("\u221AX", x, y0 + 4);
				// } else if (gate.name.equalsIgnoreCase("Toffoli")) {
				// radius = numberOfWires <= 5 ? 3 : 2;
				// x = (4 * i + 5) * xDelta / 4;
				// if (gate.yRegister) {
				// y0 = (2 * (numberOfWires - gate.qubits[0]) + 1)
				// * yDelta / 2 + gap + adjust;
				// y1 = (2 * (numberOfWires - gate.qubits[1]) + 1)
				// * yDelta / 2 + gap + adjust;
				// y2 = (2 * (numberOfWires - gate.qubits[2]) + 1)
				// * yDelta / 2 + gap + adjust;
				// } else {
				// y0 = (2 * (xRegisterSize - gate.qubits[0]) + 1)
				// * yDelta / 2 + adjust;
				// y1 = (2 * (xRegisterSize - gate.qubits[1]) + 1)
				// * yDelta / 2 + adjust;
				// y2 = (2 * (xRegisterSize - gate.qubits[2]) + 1)
				// * yDelta / 2 + adjust;
				// }
				// g.fillOval(x - radius, y0 - radius, 2 * radius, 2 *
				// radius);
				// g.fillOval(x - radius, y1 - radius, 2 * radius, 2 *
				// radius);
				// radius = numberOfWires <= 5 ? 6 : 4;
				// if ((y0 < y1) && (y1 < y2)) {
				// g.drawLine(x, y0, x, y2 + radius);
				// } else if ((y0 > y1) && (y1 > y2)) {
				// g.drawLine(x, y0, x, y2 - radius);
				// } else {
				// g.drawLine(x, y0, x, y1);
				// g.drawLine(x, y1, x, y2);
				// }
				// g.drawOval(x - radius, y2 - radius, 2 * radius, 2 *
				// radius);
				// } else if (gate.name.equalsIgnoreCase("QFT")) {
				// x = (i + 1) * xDelta;
				// if (gate.yRegister) {
				// y0 = xRegisterSize * yDelta + gap + adjust;
				// } else {
				// y0 = adjust - 1;
				// }
				// g.setColor(Color.white);
				// g.fillRect(x, y0, xDelta / 2, gateHeight - 1);
				// g.setColor(Color.black);
				// g.drawRect(x, y0, xDelta / 2, gateHeight - 1);
				// x = (4 * i + 5) * xDelta / 4 - 3;
				// g.drawString("F", x, y0 + gateHeight / 2 + 4);
				// } else if (gate.name.equalsIgnoreCase("invQFT")) {
				// x = (i + 1) * xDelta;
				// if (gate.yRegister) {
				// y0 = xRegisterSize * yDelta + gap + adjust;
				// } else {
				// y0 = adjust - 1;
				// }
				// g.setColor(Color.white);
				// g.fillRect(x, y0, xDelta / 2, gateHeight - 1);
				// g.setColor(Color.black);
				// g.drawRect(x, y0, xDelta / 2, gateHeight - 1);
				// x = (4 * i + 5) * xDelta / 4 - fontHeight / 2;
				// g.drawString("F-i", x, y0 + gateHeight / 2 + 4);
				// } else if (gate.name.equalsIgnoreCase("function")) {
				// setToolTipText("f(x)="
				// + gate.function.getFunction(0, false));
				// gateHeight--;
				// radius = numberOfWires <= 5 ? 3 : 2;
				// x = (4 * i + 5) * xDelta / 4;
				// for (int k = 0; k < xRegisterSize; k++) {
				// y0 = (2 * (xRegisterSize - k) - 1) * yDelta / 2
				// + adjust;
				// g.fillOval(x - radius, y0 - radius, 2 * radius,
				// 2 * radius);
				// }
				// y0 = yDelta / 2 + 1;
				// y1 = xRegisterSize * yDelta + gap + adjust - 2;
				// g.drawLine(x, y0, x, y1);
				// x = (i + 1) * xDelta - 1;
				// y0 = (numberOfWires - max) * yDelta + gap + adjust;
				// g.setColor(Color.white);
				// g.fillRect(x, y0, xDelta / 2 + 1, gateHeight - 1);
				// g.setColor(Color.lightGray);
				// g.drawRect(x, y0, xDelta / 2 + 1, gateHeight - 1);
				// x = (4 * i + 5) * xDelta / 4 - 3;
				// g.setColor(Color.black);
				// g.drawString("f(x)", x - 3, y0 + gateHeight / 2 + 4);
				// } else if (gate.name.equalsIgnoreCase("Rotation")) {
				// gateHeight = 14;
				// radius = numberOfWires <= 5 ? 3 : 2;
				// x = (4 * i + 5) * xDelta / 4;
				// int maxWire;
				// if (gate.yRegister) {
				// maxWire = numberOfWires;
				// } else {
				// maxWire = xRegisterSize;
				// }
				// for (int j = 0; j < gate.qubits.length - 1; j++) {
				// y = (2 * (maxWire - gate.qubits[j]) + 1) * yDelta / 2
				// + adjust;
				// if (gate.yRegister) {
				// y += yDelta / 2;
				// }
				// g.fillOval(x - radius, y - radius, 2 * radius,
				// 2 * radius);
				// if (j > 0) {
				// g.drawLine(x, y0 - radius, x, y - radius);
				// }
				// y0 = y;
				// }
				// y = (2 * (maxWire - gate.qubits[gate.qubits.length - 1])
				// + 1)
				// * yDelta / 2 + adjust;
				// if (gate.yRegister) {
				// y += gap;
				// }
				// if (gate.qubits.length > 1) {
				// g.drawLine(x, y0 - radius, x, y - radius);
				// }
				// x = (i + 1) * xDelta;
				// g.setColor(Color.white);
				// g.fillRect(x, y - gateHeight / 2, xDelta / 2,
				// gateHeight);
				// g.setColor(Color.gray);
				// g.drawRect(x, y - gateHeight / 2, xDelta / 2,
				// gateHeight);
				// // g.setColor( Color.blue );
				// g.setColor(Color.red);
				// x = (4 * i + 5) * xDelta / 4 - 12;
				// g.drawString("R ( - )", x, y + 3);
				// // g.setColor( Color.red );
				// g.setColor(Color.blue);
				// g.setFont(new java.awt.Font("Helvetica",
				// java.awt.Font.PLAIN, 2 * fontHeight / 3));
				// g.drawString(gate.axis, x + 7, y + 6);
				// g.drawString("" + (char) 960, x + 14, y - 1);
				// g.drawString("" + gate.phiAsPartOfPi, x + 15, y + 7);
				// g.setFont(new java.awt.Font("Helvetica",
				// java.awt.Font.PLAIN, fontSize));
				// g.setColor(Color.black);
				// } else if (gate.name.equalsIgnoreCase("Grover")) {
				// gateHeight = xRegisterSize * yDelta;
				// x = (i + 1) * xDelta;
				// y0 = adjust - 1;
				// g.setColor(Color.white);
				// g.fillRect(x, y0, xDelta / 2, gateHeight - 1);
				// g.setColor(Color.black);
				// g.drawRect(x, y0, xDelta / 2, gateHeight - 1);
				// x = (4 * i + 5) * xDelta / 4 - 3;
				// g.drawString("G", x, y0 + gateHeight / 2 + 4);
				// this.setToolTipText(bundle
				// .getProperty("CircuitPanel.Grover.toolTipText")
				// + gate.qubits[0]);
				// } else if (gate.name.equalsIgnoreCase("Measurement")) {
				// gateHeight--;
				// x = (i + 1) * xDelta;
				// if (gate.yRegister) {
				// y0 = (numberOfWires - max) * yDelta + gap + adjust;
				// } else {
				// y0 = (xRegisterSize - max) * yDelta + adjust - 1;
				// max += yRegisterSize;
				// min += yRegisterSize;
				// }
				// g.setColor(Color.white);
				// g.fillRect(x, y0, xDelta / 2, gateHeight - 1);
				// g.setColor(new Color(255, 0, 0));
				// g.drawRect(x, y0, xDelta / 2, gateHeight);
				// x = (4 * i + 5) * xDelta / 4 - 4;
				// g.drawString("M", x, y0 + gateHeight / 2 + 4);
				// g.setColor(Color.black);
				// }
				i++;
			} // loop over gates

			// separation line between x-register and y-register:
			if ((numOfQubits > 0)) {
				g.setColor(new java.awt.Color(127, 127, 127));
				y = gap / 2 + numOfQubits * yDelta + adjust - 1;
				g.drawLine(0, y, getWidth(), y);
				g.setColor(Color.black);
			}
		}
	}

	// Variables declaration - do not modify//GEN-BEGIN:variables
	// End of variables declaration//GEN-END:variables

	/**
	 * Sets the properties bundle for this circuit panel.
	 * 
	 * @param bundle
	 *            the properties bundle to display messages
	 */
	public void setBundle(java.util.Properties bundle) {
		this.bundle = bundle;
	}
}
